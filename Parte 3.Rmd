---
title: "Parte 3"
output:
  pdf_document: default
  html_document: default
date: "2025-10-01"
---

# Parte 3

## Estruturas de Programação

### Estruturas de Controle

Elas permitem fazer execução condicional ou seletiva de instruções conforme o resultado de condições que são testadas.

Os tipos mais comuns são:

-   IF-ELSE.
-   SWITCH ou CASES.

### Estruturas de Repetição

Também chamados de loops ou estruturas de iteração que permitem executar instruções um certo número de vezes até que uma condição seja atingida.

Os tipos mais comuns são:

-   FOR ou FOREACH.
-   WHILE.
-   REPEAT ou DO-UNTIL.

## Estruturas de Controle

### Estrutura de IF-ELSE

O IF-ELSE permite desviar a execução do código conforme uma condição cujo resultado é lógico, ou seja, TRUE ou FALSE.

Se o resultado da condição for TRUE, executa-se certas instruções.

Se o resultado da condição for FALSE, executa-se outras instruções.

#### Exemplo de estrutura IF-ELSE no R

```{r}
faltas <- 10
nota <- 70
if (nota >= 70 & faltas < 15) {
  result <- "Aprovado"
} else if (nota < 70) {
  result <- "Reprovado por nota"
} else {
  result <- "Reprovado por faltas"
}
result
```

#### Exercício - Saudação conforme o horário em automação de email marketing

Com base na hora do envio de uma mensagem, use bom dia, boa tarde ou boa noite.

- Se entre 6h00 e 11h59, então "Bom dia!"
- Se entre 12h00 e 17h59, então "Boa tarde!"
- Se entre 18h00 e 22h59, então "Boa noite!"
- Caso nenhum dos acima, não enviar a mensagem.

```{r}
library(hms)
horario <- as_hms("12:30:00")
if ((horario > as_hms("06:00:00")) & (horario < as_hms("11:59:00"))) {
  result <- "Bom dia"
} else if ((horario > as_hms("12:00:00")) & (horario < as_hms("17:59:00"))) {
  result <- "Boa tarde"
} else if ((horario > as_hms("18:00:00")) & (horario < as_hms("05:59:00"))) {
  result <- "Boa noite"
} else {
  result <- "Diga um horário"
}
result
```

#### Versão do professor:

```{r}
h <- 9

if ((h >= 6) & (h < 12)) {
  saudacao <- "Bom dia"
} else if ((h >= 13) & (h < 18)) {
  saudacao <- "Boa tarde"
} else if ((h >= 19) & (h < 23)) {
  saudacao <- "Boa noite"
} else {
  saudacao <- "Não enviar mensagem!"
  stop("Não enviar mensagem!")
}

saudacao
```

### Estrutura SWITCH

- O SWITCH nada mais é que um empilhamento de estruturas IF-ELSE.
- No entanto, ele confere mais clareza para o código e eciência.
- O caso mais comum é usar SWITCH para testar um valor contra um conjunto de strings.
- Geralmente há uma condição nal ou de escape.

#### Exemplo de Estrutura SWITCH

```{r}
#animal <- "gato"
#som <-
  #switch(animal,
         #"cachorro" = {
           #latir()
         #},
         #"gato" = {
           #miar()
         #},
         #"vaca" = {
           #mugir()
         #},
         #{
           #silencio()
         #})
#som
```

#### Exemplo - Tipos de média

**As médias estão após as # para que seja fácil de alterar no exemplo, só apagar um # e acrescentar na que não for usar**

```{r}
tipo <- "aritmetica"
#tipo <- "harmonica"
#tipo <- "geometrica"

x <- 1:10

switch(tipo,
       "aritmetica" = {
         mean(x)
       },
       "harmonica" = {
         length(x)/sum(1/x)
       },
       "geometrica" = {
         prod(x)^(1/length(x))
       },
       {
         NA_real_
       })


```

#### Versões Vetoriais

- A estrutura IF-ELSE apresentada **não é vetorial**, ou seja, no teste da condição são comparados
dois valores.
- Quando a condição tiver que ser testada sobre uma série de valores em um vetor, pode-se usar a função `base::ifelse()` ou `dplyr::if_else()`.
- A versão vetorial para a estrutura SWTICH é o `dplyr::case_when()`.

##### Exemplo

```{r}
# Notas dos alunos.
notas <- c("João" = 70, "Ana" = 89, "Márcia" = 81, "Tiago" = 65, "Rodrigo" = 35)

# Usando IF-ELSE vetorial.
ifelse(notas >= 70, "Aprovado",
       ifelse(notas >= 40, "Exame",
              "Reprovado"))
```

##### Exemplo com SWITCH vetorial

```{r}
dplyr::case_when(notas >= 70 ~ "Aprovado", 
                 notas >= 40 ~ "Exame",
                 TRUE ~ "Reprovado")
```

## Estruturas de Repetição

### Estrutura de loop FOR

O loop FOR é usado pra executar instruções um número previamente **conhecido** de vezes.

O loop itera sobre uma sequência de valores, um vetor ou lista.

Pode-se **interromper** a execução do loop ou **saltar** conforme condições que são avaliadas.

Deve-se usar o FOR para situações em que deseja fazer a execução percorrendo uma série conhecida de elementos ou número de iterações conhecido.


#### Exemplo de estrutura FOR no R

```{r}
tx_juros <- 0.01
n_meses <- 12
rend <- numeric(n_meses)
rend[1] <- 100
for (i in 2:n_meses) {
  rend[i] <- rend[i - 1] * (1 + tx_juros)
}
rend
```

```{r}
y <- c(1, 2, 1, 4, 0, NA, 3, 2, 4)
s <- 0
for (i in y) {
  if (s > 10) break
  if (is.na(i)) next
  s <- s + i
  print (s)
}
s
```

### Estrutura WHILE

O loop WHILE é usado quando precisa executar instruções um número desconhecido de vezes até que uma condição seja atendida.

A condição é testada antes das instruções serem avaliadas.

Cuidado: uma condição de parada deve ser declarada para que o loop não seja interminável.

#### Exemplo de estrutura WHILE no R

```{r}
n_numbers <- 12
total <- 0
i <- 1L
while (i < n_numbers){
  u <- total + runif(1)
  if (sum(u) > 4) break
  total <- u
  i <- i + 1L
}
total
```

### Estrutura REPEAT

O loop REPEAT é usado quando precisa executar instruções um número **desconhecido** de vezes até que uma condição seja atendida.

A condição é testada **em qualquer posição** dentro das instruções a serem executadas.

Cuidado: uma condição de parada deve ser declarada para que o loop não seja interminável.


#### Exemplo de estrutura REPEATA no R

```{r}
total <- 0
i <- 1L
repeat {
  u <- total + runif(1)
  if (sum(u) > 4 ) break
  total <- u
  i <- i + 1L
}
total
```

#### Exercício - Lançamento de Dados

Considere o seguinte jogo: lançar 3 dados até que os valores das faces sejam uma sequência, por exemplo, 3, 4 e 5 ou 1, 2 e 3.

1. Use um loop WHILE ou o REPEAT para contar quantas tentativas são necessárias até atingir o resultado.
2. Dicas:
  - use sample() para sortear 3 valores do espaço amostral.
  - em seguida ordene os valores do menor para o maior com sort().
  - calcule a diferença entre valores consecutivos com diff().

**Com WHILE**

```{r}
n_max <- 100
tentativas <- 1
while (tentativas < n_max) {
  l1 <- sample(1:6, 3, replace = TRUE) # joga os dados
  l1_ordenado <- sort(l1) # ordenada
  print(l1_ordenado)
  seque <- sum(ifelse(diff(l1_ordenado) == 1, TRUE, FALSE))
  if(seque == 2) break
  tentativas <- tentativas + 1
}

tentativas
```

**Com REPEAT**

E se quisermos saber: em média, quantos lançamentos são necessários?

Refaça n-vezes

- Para isso, pode-se usar o loop FOR com um loop WHILE dentro.
- Cada ciclo do FOR determina o número de tentativas usadas no WHILE.
- Depois é só calcular a média.
- No entanto, para situações como essa de execuções independentes das mesmas instruções, pode-se usar a replicate().


```{r}
output <- c()
for (i in 1:1000) {
  n_max <- 100
  tentativas <- 1
  while (tentativas < n_max) {
    l1 <- sample(1:6, 3, replace = TRUE) # joga os dados
    l1_ordenado <- sort(l1) # ordenada
    print(l1_ordenado)
    seque <- sum(ifelse(diff(l1_ordenado) == 1, TRUE, FALSE))
    if(seque == 2) break
    tentativas <- tentativas + 1
  }
  output[i] <- tentativas
}

mean(output)
hist(output)

```

## Funções

### O que são funções

Funções encapsulam uma tarefa composta de várias instruções.

Funções pegam valores de entrada e geram valores de saída conforme as instruções nela implementadas.

Funções permitem particionar um grande número de instruções em funções que atuam como partes de um algoritmo.

Funções permitem reuso de código de uma forma enxuta.

Permitem preservar o estado das variáveis na área de trabalho.

### Anatomia de uma Função

- Nome da função: usado para chamá-la.
- Lista de parâmetros: também chamado de lista de argumentos formais que passa argumentos atuais ou valores como variáveis de entrada.
- Corpo da função: contém a série de instruções que são realizadas.
- Retorno da função: retorna o que a função determinou com as instruções nela implementadas.

### Cuidados para implementar funções

- **Conheça o procedimento** que deseja encapsular numa função.
- colha um **nome apropriado** para a função, preferencialmente, um verbo ou composto por verbo.
- Use nomes apropriados para os argumentos da função.
  - Argumentos podem ser vetores, matrizes, listas, etc, e até outras funções.
  - Argumentos podem ter valores default.
- Coloque o resultado da função como valor de retorno.
- Se for necessário retornar mais de um objeto, use uma lista.
- Ao programar, faça os devidos **tratamentos de exceção**.
- Coloque mensagem descritivas para erros, avisos, comentários, etc.
- Modique variáveis **fora do escopo** da função apenas quando não houver outra solução.

##### Exemplo de FUNÇÃO 

```{r}
imc <- function(peso, altura) {
  imc <- peso/altura^2
  limits <- c(0, 18.5, 25, 30, Inf)
  labels <- c( "Magreza", "Adequado", "Pré-obeso", "Obesidade")
  classif <- labels[findInterval(imc, vec = limits)]
  return(list(IMC = imc, Classificação = classif))
}
```


#### Exercício - Fórmula de Bhaskara

Faça uma função que retorne as raízes de uma parábola com equação ax² + bx + c, usando a fórmula de Bhaskara.

```{r}
bhaskara <- function(a, b = 1, c = 0) {
  delta <- b^2 - 4 * a * c
  x <- (-b + c(-1, 1) * sqrt(delta))/(2 * a)
  return(x)
}

args(bhaskara)
formals(bhaskara)
body(bhaskara)

curve(2 * x^2 - 3 * x -3, from = -1, to = 3)
abline(h = 0, col = "red")

x <- bhaskara(a = 2, b = -3, c = -3)
x
```

### Tratamento de exceções

- Quando se faz funções para usos gerais e uma maior audiência, é importante fazer os tratamentos de exceção e fazer a função comunicar de forma clara com o usuário.
- Tratar exceções é prever desvios de uso ou de processamento causados, por exemplo, por:
  - Variáveis com tipos incorretos.
  - Objetos de classe incorreta.
  - Indeterminação nos resultados.
  - Falha de convergência.
  - Conexão/rede não disponível.
  - Arquivos/objetos não encontrados.
  - Etc.
- `cat()` e `print()`: Usa-se para imprimir conteúdo no console.
- `message()`: Usa-se para imprimir mensagens neutras para o usuário.
- `warning()`: Usa-se para imprimir mensagens de aviso. Ela causa a saída Warning.
- `stop()`: Usa-se para imprimir mensagens de erro. Ela causa a saída Error e interrompe a execução do código.

#### Exercício - Lançamento de dados

Reconsidere o seguinte jogo: lançar 3 dados até que os valores das faces sejam uma sequência, por exemplo, 3, 4 e 5 ou 1, 2 e 3.
1. Use um loop WHILE ou o REPEAT para contar quantas tentativas são necessárias até atingir o resultado.
2. Dicas:
  - use `sample()` para sortear 3 os valores do espaço amostral.
  - em seguida ordene os valores do menor para o maior com `sort()`.
  - calcule a diferença entre valores consecutivos com `diff()`.
3. Encapsule tudo dentro de uma função de forma a generalizar o seu jogo.

```{r}
joga_dados <- function(n_dados, n_max, n_simulacao) {
  output <- c()
  for(i in 1:n_simulacao) {
    tentativas <- 1
    while(tentativas < n_max) {
      l1 <- sample(1:6, n_dados, replace = TRUE) # joga os dados
      l1_ordenado <- sort(l1) # ordena
      seque <- sum(ifelse(diff(l1_ordenado) == 1, TRUE, FALSE))
      if(seque == c(n_dados - 1)) break
      tentativas <- tentativas + 1
    }
    output[i] <- tentativas
  }
  return(output)
}


jogadas <- joga_dados(n_dados = 3, n_max = 100, n_simulacao = 1000)
mean(jogadas)
jogadas <- joga_dados(n_dados = 4, n_max = 100, n_simulacao = 1000)
mean(jogadas)

```

### Aspectos avançados

```{r}
## Aspectos avançados
# Calculo do IMC

calcula_imc <- function(peso, altura) {
  imc <- peso/(altura^2)
  limits <- c(0, 18.5, 25, 30, Inf)
  labels <- c("Magreza", "Adequado", "Pré-obeso", "Obesidade")
  classif <- labels[findInterval(imc, limits)]
  return(list(IMC = imc, Classificao = classif))
}
calcula_imc(peso = 80, altura = 1.80)


# Argumento com valor default
calcula_imc <- function(altura, peso = 80) {
  imc <- peso/(altura^2)
  limits <- c(0, 18.5, 25, 30, Inf)
  labels <- c("Magreza", "Adequado", "Pré-obeso", "Obesidade")
  classif <- labels[findInterval(imc, limits)]
  return(list(IMC = imc, Classificao = classif))
}
calcula_imc(altura = 1.80)


## Tratando exceções
#calcula_imc <- function(altura, peso = 80) {
#  if(altura < 0) stop("Altura deve ser maior do que zero.")
#  if(peso < 0) stop("Peso deve ser maior do que zero.")
#  imc <- peso/(altura^2)
#  limits <- c(0, 18.5, 25, 30, Inf)
#  labels <- c("Magreza", "Adequado", "Pré-obeso", "Obesidade")
#  classif <- labels[findInterval(imc, limits)]
#  return(list(IMC = imc, Classificao = classif))
#}
#calcula_imc(altura = -1)


## Funções sem argumentos
calcula_imc <- function() {
  if(altura < 0) stop("Altura deve ser maior do que zero.")
  if(peso < 0) stop("Peso deve ser maior do que zero.")
  imc <- peso/(altura^2)
  limits <- c(0, 18.5, 25, 30, Inf)
  labels <- c("Magreza", "Adequado", "Pré-obeso", "Obesidade")
  classif <- labels[findInterval(imc, limits)]
  return(list(IMC = imc, Classificao = classif))
}
peso <- 70
altura <- 1.70
calcula_imc()

## Lazy evaluation
calcula_imc <- function(altura, peso = 80, altura2) {
  if(altura < 0) stop("Altura deve ser maior do que zero.")
  if(peso < 0) stop("Peso deve ser maior do que zero.")
  imc <- peso/(altura^2)
  limits <- c(0, 18.5, 25, 30, Inf)
  labels <- c("Magreza", "Adequado", "Pré-obeso", "Obesidade")
  classif <- labels[findInterval(imc, limits)]
  return(list(IMC = imc, Classificao = classif))
}
calcula_imc(altura = 1.90, peso = 90)

## Uso dos ...

calcula_imc_numero <- function(peso, altura) {
  imc <- peso/(altura^2)
  return(imc)
}

calcula_imc <- function(...) {
  imc <- calcula_imc_numero(...)
  limits <- c(0, 18.5, 25, 30, Inf)
  labels <- c("Magreza", "Adequado", "Pré-obeso", "Obesidade")
  classif <- labels[findInterval(imc, limits)]
  return(list(IMC = imc, Classificao = classif))
}

calcula_imc(peso = 90, altura = 1.70)
```

