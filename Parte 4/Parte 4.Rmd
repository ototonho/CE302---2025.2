---
title: "Parte 4"
output: html_document
date: "2025-10-26"
---

# Introdução ao Tidyverse

## Lidando com dados

### Manipulação e visualização de dados

- Manipular e visualizar dados (MVD) são atividades obrigatórias em qualquer atividade cientíca.
- A MVD determina o sucesso de uma série de etapas.
  - Entendimento dos dados.
  - Limpeza e conciliação de dados.
  - Engenharia de características.
  - Especicação de modelos.
  - Comunicação de resultados, etc.
- Fazer MVD de forma eciente requer:
  - Conhecer o processo e suas etapas.
  - Dominar a tecnologia para execução.
- Linguagens de programação oferecem uma série de vantagens: reproduzível, extensível, escalonável, integrável, portável, etc.

### Principal Referência - R for Data Science

[Workflow do Tidyverse](https://oliviergimenez.github.io/intro_tidyverse/#7)

## O framework tidyverse

### O tidyverse

- Oferece uma reimplementação e extensão das funcionalidades do R para manipulação e visualização de dados.
- É uma coleção de 8 pacotes que operam em harmonia.
- Foram planejados e construídos para trabalhar em conjunto.
- Possuem gramática, organização, losoa e estruturas de dados mais claras.
- Maior facilidade de desenvolvimento de código e portabilidade.
- Outros pacotes acoplam muito bem com o {tidyverse}.
- [Pacotes:](https://www.tidyverse.org/packages/).
- [R4DS:](https://r4ds.had.co.nz/).
- [Cookbook:](https://rstudio-education.github.io/tidyversecookbook/program.html).

```{r}
library(tidyverse)
tidyverse_packages()
```

### Os pacotes do {tidyverse}

## Princípios dos dados organizados

- Cada variável está em uma coluna.
- Cada observação está em uma linha.
- Cada tipo de unidade observacional está em uma célula.

#### Tarefas comuns ao lidar com dados

- Importação.
- Arrumação.
- Manipulação.
- Combinação.
- Exportação.


## Importação de dados

### O pacote {readr}

- O processo de análise de dados começa com a importação dos dados para o ambiente de manipulação.
- Existem vários meios para armazenar dados.
  - Arquivos de texto pleno (tsv, txt, csv, etc).
  - Planilhas eletrônicas.
  - Bancos de dados relacionais.
  - Etc.

- O **readr** tem recursos para importação de dados retangulares na forma de texto pleno.
- **Documentação**:
  - [readr](https://readr.tidyverse.org/).
  - [data import](https://r4ds.had.co.nz/data-import.html).
  - [cran-r](https://cran.r-project.org/package=readr).

### Importando arquivos de texto pleno

#### Importando dados do tipo .txt.

```{r}
library(readr)
url <- "http://leg.ufpr.br/~wagner/scientificR/anovareg.txt"
dados <- read_tsv(url, col_names = TRUE)

head(dados)

```

#### Importando dados do tipo .csv. 

```{r}
library(readr) 
url <- "http://leg.ufpr.br/~wagner/scientificR/reglinear.csv"
dados<-read_table(url,col_names=TRUE)

head(dados)

```

#### Importando uma planilha eletrônica

```{r}
library(readxl)
library(httr)
url <- "http://leg.ufpr.br/~wagner/scientificR/meus_dados.xlsx"
GET(url, write_disk(tf <- tempfile(fileext = ".xlsx"))) # primeiro faz um download temporário

tb <- read_excel(tf, sheet = "mtcars")
head(tb[,1:4])
```

### Conexão com bancos de dados relacionais 

#### Conectando e importando tabelas de banco srelacionais - MySQL.

```{r}
library(DBI) 
library(RMySQL) 
# Criando a conexão. 
db <- dbConnect( 
  RMySQL::MySQL(), 
  user = "rfamro",   password = "", 
  port = 4497, dbname = "Rfam", 
  host = "mysql-rfam-public.ebi.ac.uk") 

# Lista as tabelas do BD. 
dbListTables(db) 

# Listas as colunas em uma tabela. 
dbListFields(db, "keywords") 

# Importanto a tabela. 
tb <- RMySQL::dbFetch( 
  RMySQL::dbSendQuery( 
    db, "SELECT * FROM keywords")) 
str(tb) 

# Desconecta 
dbDisconnect(db) 
```

## Consumindo dados de APIs

- API (Application Programming Interface) é um conjunto de rotinas que permitem diferentes softwares interagirem.
- Pense como uma espécie de ponte ou garçom entre sistemas/softwares.
- Por meio de uma API você pode usar modelos pré-prontos de diversos fornecedores.
- Acessar dados de fornecedores especializados.
- Uma API é o que vai permitir criar novas soluções usando dados/modelos existentes.

### Como funciona?

- **Requisição**: Você envia um 'pedido' para a API.
- **Processamento**: O serviço (dados/modelos, etc) processa o pedido e gera uma resposta.
- **Resposta**: A API devolve a resposta para você.

[Fluxo de chamada de API.](https://www.postman.com/what-is-an-api/)

### A importância de APIs para Cientistas de Dados

- APIs são portas de entrada para dados e serviços.
- Permitem: automação, integração e acesso em tempo real a informações externas.
- Entender como acessar e construir APIs vai permitir ir além do uso de planilhas e banco de dados.

#### Casos práticos em Ciência de Dados

- Coleta de dados em larga escala (ex: dados climáticos, financeiros, sociais).
- Integração com modelos de IA, como o ChatGPT ou modelos de predição customizados. 
- Dashboards dinâmicos com dados atualizados via APIs REST.
- Automatização de processos de negócio: envio de relatórios, alertas, atualizações.

### Pacote httr

- httr é um pacote para facilitar o consumo de APIs.
- Ele abstrai os detalhes do protocolo HTTP, permitindo chamadas simples e legíveis.
- Ideal para requisições GET, POST, PUT, DELETE, com suporte a autenticação e manipulação de headers.
- Instação direto do CRAN

```{r}
## Instalação do pacote
install.packages("httr")

```

#### Principais funções

| Função | Descrição |
|--------|-----------|
| GET() | Realiza uma requisição HTTP GET |
| POST() | Envia dados para a API via HTTP POST |
| PUT() | Atualiza recursos |
| DELETE() | Remove recursos |
| add_headers() | Adiciona cabeçalhos HTTP, como tokens |
| content() | Extrai e interpreta o conteúdo da resposta |
|--------|-----------|

##### Procurar por documentação oficial

#### Exemplo de requisição httr

Vamos acessar a API do github.

```{r}
library(httr) ## Carregando o pacote
res <- GET("https://api.github.com/users/hadley") ## Requisição
user_info <- content(res, as = "parsed") ## Capturando o conteúdo
user_info$login ## Verificando a informação recebida
```
### Acessando APIs; Pacote httr

#### Exemplos

Exemplo de requisição do tipo GET


GET("https://api.exemplo.com/dados")


É comum precisar mandarmos dados para a API.
Exemplo de requisição do tipo POST


POST("https://api.exemplo.com/envio",
body = list(nome = "Ana", idade = 30))


Para capturar o retorno da API usamos a função content()


res <- GET("https://api.exemplo.com/dados")
status_code(res) 
dados <- content(res, as = "parsed")


Importante saber lidar com erros da API.


if (status_code(res) == 200) {
content(res, as = "parsed")
} else {
message("Erro: ", status_code(res))
}

### Dicas e boas práticas

- Sempre leia a documentação da API
- Use tryCatch() para capturar falhas inesperadas
- Armazene chaves em arquivos .env (nunca no código!)
- Script de exemplos práticos: acesso_apis.R.

[imagem sobre APIs](https://www.geeksforgeeks.org/what-is-an-api/)

## Introdução ao dplyr

O dplyr é a gramática para manipulação de dados.
- Apresenta um conjunto consistente de verbos para atuar sobre tabelas.

- Verbos principais: arrange(), select(), mutate(), slice, rename(), filter(), summarise(), etc.

- Sufixos: _at() , _if() , _all() , etc.
- Agrupamento: group_by() e ungroup() .
- Junções: inner_join(), full_join(), left_join(), right_join().
- Funções resumo: n(), n_distinct(), first(), last(), nth(), etc.

### Referências úteis

[Cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf)
Documentação oficial:
[manual](https://dplyr.tidyverse.org/)
[Capítulo do livro](https://r4ds.had.co.nz/relational-data.html)
[help do Cran](https://cran.r-project.org/package=dplyr)

## Setup pipe

### Carregamento dos pacotes necessários

```{r}
require(tidyverse)

dados <- readr::read_csv("C:/Users/anton/OneDrive/Área de Trabalho/CE302---2025.2/Parte 4/Mental Health Dataset.csv")
## Para vermos os dados, podemos utilizar a função head()
head(dados, 2)

```

### Operador Pipe

- O operador %>% é chamado de *pipe* e é utilizado para encadear funções.

- Utilizado para facilitar a leitura e escrita de códigos.
  - x %>% f é equivalente à f(x)
  - x %>% f(y) é equivalente à f(x, y)
  - x %>% f %>% g %>% h é equivalente à h(g(f(x)))

- O %>% significa que o elemento à esquerda será avaliado pela função à direita.

- Podemos também utilizar o . como espaço reservado para o elemento à esquerda, isto é:
  - x %>% f(y, .) é equivalente à f(y, x)
  - x %>% f(., y) é equivalente à f(x, y)
  - x %>% f(y, z = .) é equivalente à f(y, z = x) .

#### Exemplo do uso do operador %>%

Suponha que queremos calcular o cosseno dos valores únicos de um vetor x , ordená-los em ordem decrescente.

1) Sem o uso do operador %>% : Sem identação

```{r}
x <- c(-2:2)
x

# Opção 1 - Sem identação
sort(cos(unique(x)), decreasing = TRUE)
```
2) Sem o uso do operador %>% : Com identação

```{r}
# Opção 2 - Com identação
sort(
  cos(
    unique(
      x
      )
    ),
  decreasing = TRUE)
```
3) Exemplo do uso do operador %>%

```{r}
# Opção 3 - Utilizando o operador %>%
require(magrittr)

x %>% 
  unique() %>% 
  cos() %>%
  sort(decreasing = TRUE)
```

### Pipe de Atribuição %<>%

- O operador %<>% é utilizado para atribuir o resultado de uma operação ao objeto original.
- Isto é, x %<>% f() é equivalente à x <- f(x) .

```{r}
x <- 1:10
x

x %<>% log()
x
```

## Mutate

- Criando Variáveis com mutate()

- Para criar novas variáveis, podemos utilizar a função mutate() .

- Utilizando o banco de dados dados , vamos criar uma nova variável chamada mercosul que indica se o país é membro do Mercosul ou não.

```{r}
## Criar Colunas com Mutate
dados <- dados %>% 
  mutate(mercosul = ifelse(Country %in%
                             c("Argentina", "Brazil", "Paraguay", "Uruguay"),
                           "Mercosul", "Não Mercosul"))
glimpse(dados)
```

## Selecionando e Removendo Variáveis

### Selecionando Variáveis com select()

- Para selecionar variáveis, podemos utilizar a função select() .
- Seleção por nomes: Vamos selecionar as variáveis Country, Timestamp, Days_Indoors e mercosul.

```{r}
## Selecionar colunas com select()
dados2 <- dados %>% 
  select(Country, Timestamp, Days_Indoors, mercosul) # selecionando variáveis nominalmente
glimpse(dados2)
```
### Incrementando o select()

#### Seleção por índices

- Podemos utilizar o índice das variáveis para selecioná-las.

```{r}
dados3 <- dados %>% 
  select(3:5) # variáveis 3, 4 e 5
glimpse(dados3)
```

#### Seleção Intervalar

- Podemos utilizar o operador: para selecionar um intervalo de variáveis.
- Vamos selecionar as variáveis treatment até Changes_Habits.

```{r}
dados4 <- dados %>% 
  select(treatment:Changes_Habits) 
glimpse(dados4)
```
#### Selecionando várias colunas por padrão

- Podemos utilizar a função starts_with(), ends_with(), contains() e matches() para selecionar variáveis que atendam a um padrão.

- Vamos selecionar as variáveis que começam com a letra t.

```{r}
dados6 <- dados %>% 
  select(starts_with("t"))
glimpse(dados6)
```

- Vamos selecionar as variáveis que terminam com a letra s.

```{r}
dados7 <- dados %>% 
  select(ends_with("s"))
glimpse(dados7)
```

- Vamos selecionar as variáveis que contém as letra ing.

```{r}
dados8 <- dados %>% 
  select(contains("ing"))
glimpse(dados8)
```

- Vamos selecionar as variáveis que contém a letra t ou T.

```{r}
dados9 <- dados %>% 
  select(matches("[tT]"))
glimpse(dados9)
```

### Removendo Variáveis com select()

- Para remover variáveis, podemos utilizar a função select() com o operador - .
- Vamos remover as variáveis Country, Timestamp, Days_Indoors e mercosul.

```{r}
dados10 <- dados %>% 
  select(-Country, -Timestamp, -Days_Indoors, -mercosul)
glimpse(dados10)
```

```{r}
dados11 <- dados %>% 
  select(-c(Country, Timestamp, Days_Indoors, mercosul))
glimpse(dados11)
```


### Seleção de variáveis por Tipos específicos de dados

- Podemos utilizar a função select_if() para selecionar variáveis que atendam a um critério específico.
- Vamos selecionar as variáveis que são do tipo character.

```{r}
dados12 <- dados %>% 
  select_if(is.character)
glimpse(dados12)
```

### Seleção por critérios

- Podemos definir externamente um critério para selecionar variáveis. Por exemplo, temos o nome de algumas variáveis que queremos selecionar.
- all_of() é utilizado para selecionar variáveis que atendam a um critério externo.
- any_of() é utilizado para selecionar variáveis que atendam a pelo menos um critério externo.

```{r}
dados %>% 
  select_if(is.logical) #nenhuma

dados %>% 
  select_if(is.numeric) #nenhuma

variaveis <- c("Country", "Timestamp", "Days_Indoors", "mercosul")
dados13 <- dados %>% 
  select(all_of(variaveis))
glimpse(dados13)

variaveis <- c("Country", "Timestamp", "Days_Indoors", "mercosul", "Loss_of_Smell")
dados14 <- dados %>% 
  select(any_of(variaveis))
glimpse(dados14)
```

## Filtrando observações

Para filtrar observações, podemos utilizar a função filter()

- ==: Igual a
- !=: Diferente de
- <: Menor que
- >: Maior que
- <=: Menor ou igual a
- >=: Maior ou igual a

Vamos filtrar as observações pertencentes ao mercosul.

Para aprendermos filtros, vamos usar o banco de dados car_crash .
