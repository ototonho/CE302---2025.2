---
title: "Parte 4"
output: html_document
date: "2025-10-26"
---

# Introdução ao Tidyverse

## Lidando com dados

### Manipulação e visualização de dados

- Manipular e visualizar dados (MVD) são atividades obrigatórias em qualquer atividade cientíca.
- A MVD determina o sucesso de uma série de etapas.
  - Entendimento dos dados.
  - Limpeza e conciliação de dados.
  - Engenharia de características.
  - Especicação de modelos.
  - Comunicação de resultados, etc.
- Fazer MVD de forma eciente requer:
  - Conhecer o processo e suas etapas.
  - Dominar a tecnologia para execução.
- Linguagens de programação oferecem uma série de vantagens: reproduzível, extensível, escalonável, integrável, portável, etc.

### Principal Referência - R for Data Science

[Workflow do Tidyverse](https://oliviergimenez.github.io/intro_tidyverse/#7)

## O framework tidyverse

### O tidyverse

- Oferece uma reimplementação e extensão das funcionalidades do R para manipulação e visualização de dados.
- É uma coleção de 8 pacotes que operam em harmonia.
- Foram planejados e construídos para trabalhar em conjunto.
- Possuem gramática, organização, losoa e estruturas de dados mais claras.
- Maior facilidade de desenvolvimento de código e portabilidade.
- Outros pacotes acoplam muito bem com o {tidyverse}.
- [Pacotes:](https://www.tidyverse.org/packages/).
- [R4DS:](https://r4ds.had.co.nz/).
- [Cookbook:](https://rstudio-education.github.io/tidyversecookbook/program.html).

```{r}
library(tidyverse)
tidyverse_packages()
```

### Os pacotes do {tidyverse}

## Princípios dos dados organizados

- Cada variável está em uma coluna.
- Cada observação está em uma linha.
- Cada tipo de unidade observacional está em uma célula.

#### Tarefas comuns ao lidar com dados

- Importação.
- Arrumação.
- Manipulação.
- Combinação.
- Exportação.


## Importação de dados

### O pacote {readr}

- O processo de análise de dados começa com a importação dos dados para o ambiente de manipulação.
- Existem vários meios para armazenar dados.
  - Arquivos de texto pleno (tsv, txt, csv, etc).
  - Planilhas eletrônicas.
  - Bancos de dados relacionais.
  - Etc.

- O **readr** tem recursos para importação de dados retangulares na forma de texto pleno.
- **Documentação**:
  - [readr](https://readr.tidyverse.org/).
  - [data import](https://r4ds.had.co.nz/data-import.html).
  - [cran-r](https://cran.r-project.org/package=readr).

### Importando arquivos de texto pleno

#### Importando dados do tipo .txt.

```{r}
library(readr)
url <- "http://leg.ufpr.br/~wagner/scientificR/anovareg.txt"
dados <- read_tsv(url, col_names = TRUE)

head(dados)

```

#### Importando dados do tipo .csv. 

```{r}
library(readr) 
url <- "http://leg.ufpr.br/~wagner/scientificR/reglinear.csv"
dados<-read_table(url,col_names=TRUE)

head(dados)

```

#### Importando uma planilha eletrônica

```{r}
library(readxl)
library(httr)
url <- "http://leg.ufpr.br/~wagner/scientificR/meus_dados.xlsx"
GET(url, write_disk(tf <- tempfile(fileext = ".xlsx"))) # primeiro faz um download temporário

tb <- read_excel(tf, sheet = "mtcars")
head(tb[,1:4])
```

### Conexão com bancos de dados relacionais 

#### Conectando e importando tabelas de banco srelacionais - MySQL.

```{r}
library(DBI) 
library(RMySQL) 
# Criando a conexão. 
db <- dbConnect( 
  RMySQL::MySQL(), 
  user = "rfamro",   password = "", 
  port = 4497, dbname = "Rfam", 
  host = "mysql-rfam-public.ebi.ac.uk") 

# Lista as tabelas do BD. 
dbListTables(db) 

# Listas as colunas em uma tabela. 
dbListFields(db, "keywords") 

# Importanto a tabela. 
tb <- RMySQL::dbFetch( 
  RMySQL::dbSendQuery( 
    db, "SELECT * FROM keywords")) 
str(tb) 

# Desconecta 
dbDisconnect(db) 
```

## Consumindo dados de APIs

- API (Application Programming Interface) é um conjunto de rotinas que permitem diferentes softwares interagirem.
- Pense como uma espécie de ponte ou garçom entre sistemas/softwares.
- Por meio de uma API você pode usar modelos pré-prontos de diversos fornecedores.
- Acessar dados de fornecedores especializados.
- Uma API é o que vai permitir criar novas soluções usando dados/modelos existentes.

### Como funciona?

- **Requisição**: Você envia um 'pedido' para a API.
- **Processamento**: O serviço (dados/modelos, etc) processa o pedido e gera uma resposta.
- **Resposta**: A API devolve a resposta para você.

[Fluxo de chamada de API.](https://www.postman.com/what-is-an-api/)

### A importância de APIs para Cientistas de Dados

- APIs são portas de entrada para dados e serviços.
- Permitem: automação, integração e acesso em tempo real a informações externas.
- Entender como acessar e construir APIs vai permitir ir além do uso de planilhas e banco de dados.

#### Casos práticos em Ciência de Dados

- Coleta de dados em larga escala (ex: dados climáticos, financeiros, sociais).
- Integração com modelos de IA, como o ChatGPT ou modelos de predição customizados. 
- Dashboards dinâmicos com dados atualizados via APIs REST.
- Automatização de processos de negócio: envio de relatórios, alertas, atualizações.

### Pacote httr

- httr é um pacote para facilitar o consumo de APIs.
- Ele abstrai os detalhes do protocolo HTTP, permitindo chamadas simples e legíveis.
- Ideal para requisições GET, POST, PUT, DELETE, com suporte a autenticação e manipulação de headers.
- Instação direto do CRAN

```{r}
## Instalação do pacote
install.packages("httr")

```

#### Principais funções

| Função | Descrição |
|--------|-----------|
| GET() | Realiza uma requisição HTTP GET |
| POST() | Envia dados para a API via HTTP POST |
| PUT() | Atualiza recursos |
| DELETE() | Remove recursos |
| add_headers() | Adiciona cabeçalhos HTTP, como tokens |
| content() | Extrai e interpreta o conteúdo da resposta |
|--------|-----------|

##### Procurar por documentação oficial

#### Exemplo de requisição httr

Vamos acessar a API do github.

```{r}
library(httr) ## Carregando o pacote
res <- GET("https://api.github.com/users/hadley") ## Requisição
user_info <- content(res, as = "parsed") ## Capturando o conteúdo
user_info$login ## Verificando a informação recebida
```
### Acessando APIs; Pacote httr

#### Exemplos

Exemplo de requisição do tipo GET


GET("https://api.exemplo.com/dados")


É comum precisar mandarmos dados para a API.
Exemplo de requisição do tipo POST


POST("https://api.exemplo.com/envio",
body = list(nome = "Ana", idade = 30))


Para capturar o retorno da API usamos a função content()


res <- GET("https://api.exemplo.com/dados")
status_code(res) 
dados <- content(res, as = "parsed")


Importante saber lidar com erros da API.


if (status_code(res) == 200) {
content(res, as = "parsed")
} else {
message("Erro: ", status_code(res))
}

### Dicas e boas práticas

- Sempre leia a documentação da API
- Use tryCatch() para capturar falhas inesperadas
- Armazene chaves em arquivos .env (nunca no código!)
- Script de exemplos práticos: acesso_apis.R.

[imagem sobre APIs](https://www.geeksforgeeks.org/what-is-an-api/)

## Introdução ao dplyr

O dplyr é a gramática para manipulação de dados.
- Apresenta um conjunto consistente de verbos para atuar sobre tabelas.

- Verbos principais: arrange(), select(), mutate(), slice, rename(), filter(), summarise(), etc.

- Sufixos: _at() , _if() , _all() , etc.
- Agrupamento: group_by() e ungroup() .
- Junções: inner_join(), full_join(), left_join(), right_join().
- Funções resumo: n(), n_distinct(), first(), last(), nth(), etc.

### Referências úteis

[Cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf)
Documentação oficial:
[manual](https://dplyr.tidyverse.org/)
[Capítulo do livro](https://r4ds.had.co.nz/relational-data.html)
[help do Cran](https://cran.r-project.org/package=dplyr)

## Setup pipe

### Carregamento dos pacotes necessários

```{r}
require(tidyverse)

# dados <- readr::read_csv("data/Mental Health Dataset.csv")
## Para vermos os dados, podemos utilizar a função head()
# head(dados, 2)

```

### Operador Pipe

- O operador %>% é chamado de *pipe* e é utilizado para encadear funções.

- Utilizado para facilitar a leitura e escrita de códigos.
  - x %>% f é equivalente à f(x)
  - x %>% f(y) é equivalente à f(x, y)
  - x %>% f %>% g %>% h é equivalente à h(g(f(x)))

- O %>% significa que o elemento à esquerda será avaliado pela função à direita.

- Podemos também utilizar o . como espaço reservado para o elemento à esquerda, isto é:
  - x %>% f(y, .) é equivalente à f(y, x)
  - x %>% f(., y) é equivalente à f(x, y)
  - x %>% f(y, z = .) é equivalente à f(y, z = x) .

