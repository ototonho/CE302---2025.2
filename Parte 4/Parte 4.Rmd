---
title: "Parte 4"
output:
  pdf_document: default
  html_document: default
date: "2025-10-26"
---

# Introdução ao Tidyverse

## Lidando com dados

### Manipulação e visualização de dados

- Manipular e visualizar dados (MVD) são atividades obrigatórias em qualquer atividade cientíca.
- A MVD determina o sucesso de uma série de etapas.
  - Entendimento dos dados.
  - Limpeza e conciliação de dados.
  - Engenharia de características.
  - Especicação de modelos.
  - Comunicação de resultados, etc.
- Fazer MVD de forma eciente requer:
  - Conhecer o processo e suas etapas.
  - Dominar a tecnologia para execução.
- Linguagens de programação oferecem uma série de vantagens: reproduzível, extensível, escalonável, integrável, portável, etc.

### Principal Referência - R for Data Science

[Workflow do Tidyverse](https://oliviergimenez.github.io/intro_tidyverse/#7)

## O framework tidyverse

### O tidyverse

- Oferece uma reimplementação e extensão das funcionalidades do R para manipulação e visualização de dados.
- É uma coleção de 8 pacotes que operam em harmonia.
- Foram planejados e construídos para trabalhar em conjunto.
- Possuem gramática, organização, losoa e estruturas de dados mais claras.
- Maior facilidade de desenvolvimento de código e portabilidade.
- Outros pacotes acoplam muito bem com o {tidyverse}.
- [Pacotes:](https://www.tidyverse.org/packages/).
- [R4DS:](https://r4ds.had.co.nz/).
- [Cookbook:](https://rstudio-education.github.io/tidyversecookbook/program.html).

```{r}
library(tidyverse)
tidyverse_packages()
```

### Os pacotes do {tidyverse}

## Princípios dos dados organizados

- Cada variável está em uma coluna.
- Cada observação está em uma linha.
- Cada tipo de unidade observacional está em uma célula.

#### Tarefas comuns ao lidar com dados

- Importação.
- Arrumação.
- Manipulação.
- Combinação.
- Exportação.


## Importação de dados

### O pacote {readr}

- O processo de análise de dados começa com a importação dos dados para o ambiente de manipulação.
- Existem vários meios para armazenar dados.
  - Arquivos de texto pleno (tsv, txt, csv, etc).
  - Planilhas eletrônicas.
  - Bancos de dados relacionais.
  - Etc.

- O **readr** tem recursos para importação de dados retangulares na forma de texto pleno.
- **Documentação**:
  - [readr](https://readr.tidyverse.org/).
  - [data import](https://r4ds.had.co.nz/data-import.html).
  - [cran-r](https://cran.r-project.org/package=readr).

### Importando arquivos de texto pleno

#### Importando dados do tipo .txt.

```{r}
library(readr)
url <- "http://leg.ufpr.br/~wagner/scientificR/anovareg.txt"
dados <- read_tsv(url, col_names = TRUE)

head(dados)

```

#### Importando dados do tipo .csv. 

```{r}
library(readr) 
url <- "http://leg.ufpr.br/~wagner/scientificR/reglinear.csv"
dados<-read_table(url,col_names=TRUE)

head(dados)

```

#### Importando uma planilha eletrônica

```{r}
library(readxl)
library(httr)
url <- "http://leg.ufpr.br/~wagner/scientificR/meus_dados.xlsx"
GET(url, write_disk(tf <- tempfile(fileext = ".xlsx"))) # primeiro faz um download temporário

tb <- read_excel(tf, sheet = "mtcars")
head(tb[,1:4])
```

### Conexão com bancos de dados relacionais 

#### Conectando e importando tabelas de banco srelacionais - MySQL.

```{r}
library(DBI) 
library(RMySQL) 
# Criando a conexão. 
db <- dbConnect( 
  RMySQL::MySQL(), 
  user = "rfamro",   password = "", 
  port = 4497, dbname = "Rfam", 
  host = "mysql-rfam-public.ebi.ac.uk") 

# Lista as tabelas do BD. 
dbListTables(db) 

# Listas as colunas em uma tabela. 
dbListFields(db, "keywords") 

# Importanto a tabela. 
tb <- RMySQL::dbFetch( 
  RMySQL::dbSendQuery( 
    db, "SELECT * FROM keywords")) 
str(tb) 

# Desconecta 
dbDisconnect(db) 
```

## Consumindo dados de APIs

- API (Application Programming Interface) é um conjunto de rotinas que permitem diferentes softwares interagirem.
- Pense como uma espécie de ponte ou garçom entre sistemas/softwares.
- Por meio de uma API você pode usar modelos pré-prontos de diversos fornecedores.
- Acessar dados de fornecedores especializados.
- Uma API é o que vai permitir criar novas soluções usando dados/modelos existentes.

### Como funciona?

- **Requisição**: Você envia um 'pedido' para a API.
- **Processamento**: O serviço (dados/modelos, etc) processa o pedido e gera uma resposta.
- **Resposta**: A API devolve a resposta para você.

[Fluxo de chamada de API.](https://www.postman.com/what-is-an-api/)

### A importância de APIs para Cientistas de Dados

- APIs são portas de entrada para dados e serviços.
- Permitem: automação, integração e acesso em tempo real a informações externas.
- Entender como acessar e construir APIs vai permitir ir além do uso de planilhas e banco de dados.

#### Casos práticos em Ciência de Dados

- Coleta de dados em larga escala (ex: dados climáticos, financeiros, sociais).
- Integração com modelos de IA, como o ChatGPT ou modelos de predição customizados. 
- Dashboards dinâmicos com dados atualizados via APIs REST.
- Automatização de processos de negócio: envio de relatórios, alertas, atualizações.

### Pacote httr

- httr é um pacote para facilitar o consumo de APIs.
- Ele abstrai os detalhes do protocolo HTTP, permitindo chamadas simples e legíveis.
- Ideal para requisições GET, POST, PUT, DELETE, com suporte a autenticação e manipulação de headers.
- Instação direto do CRAN

```{r}
## Instalação do pacote
install.packages("httr")

```

#### Principais funções

| Função | Descrição |
|--------|-----------|
| GET() | Realiza uma requisição HTTP GET |
| POST() | Envia dados para a API via HTTP POST |
| PUT() | Atualiza recursos |
| DELETE() | Remove recursos |
| add_headers() | Adiciona cabeçalhos HTTP, como tokens |
| content() | Extrai e interpreta o conteúdo da resposta |
|--------|-----------|

##### Procurar por documentação oficial

#### Exemplo de requisição httr

Vamos acessar a API do github.

```{r}
library(httr) ## Carregando o pacote
res <- GET("https://api.github.com/users/hadley") ## Requisição
user_info <- content(res, as = "parsed") ## Capturando o conteúdo
user_info$login ## Verificando a informação recebida
```
### Acessando APIs; Pacote httr

#### Exemplos

Exemplo de requisição do tipo GET


GET("https://api.exemplo.com/dados")


É comum precisar mandarmos dados para a API.
Exemplo de requisição do tipo POST


POST("https://api.exemplo.com/envio",
body = list(nome = "Ana", idade = 30))


Para capturar o retorno da API usamos a função content()


res <- GET("https://api.exemplo.com/dados")
status_code(res) 
dados <- content(res, as = "parsed")


Importante saber lidar com erros da API.


if (status_code(res) == 200) {
content(res, as = "parsed")
} else {
message("Erro: ", status_code(res))
}

### Dicas e boas práticas

- Sempre leia a documentação da API
- Use tryCatch() para capturar falhas inesperadas
- Armazene chaves em arquivos .env (nunca no código!)
- Script de exemplos práticos: acesso_apis.R.

[imagem sobre APIs](https://www.geeksforgeeks.org/what-is-an-api/)

## Introdução ao dplyr

O dplyr é a gramática para manipulação de dados.
- Apresenta um conjunto consistente de verbos para atuar sobre tabelas.

- Verbos principais: arrange(), select(), mutate(), slice, rename(), filter(), summarise(), etc.

- Sufixos: _at() , _if() , _all() , etc.
- Agrupamento: group_by() e ungroup() .
- Junções: inner_join(), full_join(), left_join(), right_join().
- Funções resumo: n(), n_distinct(), first(), last(), nth(), etc.

### Referências úteis

[Cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf)
Documentação oficial:
[manual](https://dplyr.tidyverse.org/)
[Capítulo do livro](https://r4ds.had.co.nz/relational-data.html)
[help do Cran](https://cran.r-project.org/package=dplyr)

## Setup pipe

### Carregamento dos pacotes necessários

```{r}
require(tidyverse)

dados <- readr::read_csv("C:/Users/anton/OneDrive/Área de Trabalho/CE302---2025.2/Parte 4/Mental Health Dataset.csv")
## Para vermos os dados, podemos utilizar a função head()
head(dados, 2)

```

### Operador Pipe

- O operador %>% é chamado de *pipe* e é utilizado para encadear funções.

- Utilizado para facilitar a leitura e escrita de códigos.
  - x %>% f é equivalente à f(x)
  - x %>% f(y) é equivalente à f(x, y)
  - x %>% f %>% g %>% h é equivalente à h(g(f(x)))

- O %>% significa que o elemento à esquerda será avaliado pela função à direita.

- Podemos também utilizar o . como espaço reservado para o elemento à esquerda, isto é:
  - x %>% f(y, .) é equivalente à f(y, x)
  - x %>% f(., y) é equivalente à f(x, y)
  - x %>% f(y, z = .) é equivalente à f(y, z = x) .

#### Exemplo do uso do operador %>%

Suponha que queremos calcular o cosseno dos valores únicos de um vetor x , ordená-los em ordem decrescente.

1) Sem o uso do operador %>% : Sem identação

```{r}
x <- c(-2:2)
x

# Opção 1 - Sem identação
sort(cos(unique(x)), decreasing = TRUE)
```
2) Sem o uso do operador %>% : Com identação

```{r}
# Opção 2 - Com identação
sort(
  cos(
    unique(
      x
      )
    ),
  decreasing = TRUE)
```
3) Exemplo do uso do operador %>%

```{r}
# Opção 3 - Utilizando o operador %>%
require(magrittr)

x %>% 
  unique() %>% 
  cos() %>%
  sort(decreasing = TRUE)
```

### Pipe de Atribuição %<>%

- O operador %<>% é utilizado para atribuir o resultado de uma operação ao objeto original.
- Isto é, x %<>% f() é equivalente à x <- f(x) .

```{r}
x <- 1:10
x

x %<>% log()
x
```

## Mutate

- Criando Variáveis com mutate()

- Para criar novas variáveis, podemos utilizar a função mutate() .

- Utilizando o banco de dados dados , vamos criar uma nova variável chamada mercosul que indica se o país é membro do Mercosul ou não.

```{r}
## Criar Colunas com Mutate
dados <- dados %>% 
  mutate(mercosul = ifelse(Country %in%
                             c("Argentina", "Brazil", "Paraguay", "Uruguay"),
                           "Mercosul", "Não Mercosul"))
glimpse(dados)
```

## Selecionando e Removendo Variáveis

### Selecionando Variáveis com select()

- Para selecionar variáveis, podemos utilizar a função select() .
- Seleção por nomes: Vamos selecionar as variáveis Country, Timestamp, Days_Indoors e mercosul.

```{r}
## Selecionar colunas com select()
dados2 <- dados %>% 
  select(Country, Timestamp, Days_Indoors, mercosul) # selecionando variáveis nominalmente
glimpse(dados2)
```
### Incrementando o select()

#### Seleção por índices

- Podemos utilizar o índice das variáveis para selecioná-las.

```{r}
dados3 <- dados %>% 
  select(3:5) # variáveis 3, 4 e 5
glimpse(dados3)
```

#### Seleção Intervalar

- Podemos utilizar o operador: para selecionar um intervalo de variáveis.
- Vamos selecionar as variáveis treatment até Changes_Habits.

```{r}
dados4 <- dados %>% 
  select(treatment:Changes_Habits) 
glimpse(dados4)
```
#### Selecionando várias colunas por padrão

- Podemos utilizar a função starts_with(), ends_with(), contains() e matches() para selecionar variáveis que atendam a um padrão.

- Vamos selecionar as variáveis que começam com a letra t.

```{r}
dados6 <- dados %>% 
  select(starts_with("t"))
glimpse(dados6)
```

- Vamos selecionar as variáveis que terminam com a letra s.

```{r}
dados7 <- dados %>% 
  select(ends_with("s"))
glimpse(dados7)
```

- Vamos selecionar as variáveis que contém as letra ing.

```{r}
dados8 <- dados %>% 
  select(contains("ing"))
glimpse(dados8)
```

- Vamos selecionar as variáveis que contém a letra t ou T.

```{r}
dados9 <- dados %>% 
  select(matches("[tT]"))
glimpse(dados9)
```

### Removendo Variáveis com select()

- Para remover variáveis, podemos utilizar a função select() com o operador - .
- Vamos remover as variáveis Country, Timestamp, Days_Indoors e mercosul.

```{r}
dados10 <- dados %>% 
  select(-Country, -Timestamp, -Days_Indoors, -mercosul)
glimpse(dados10)
```

```{r}
dados11 <- dados %>% 
  select(-c(Country, Timestamp, Days_Indoors, mercosul))
glimpse(dados11)
```


### Seleção de variáveis por Tipos específicos de dados

- Podemos utilizar a função select_if() para selecionar variáveis que atendam a um critério específico.
- Vamos selecionar as variáveis que são do tipo character.

```{r}
dados12 <- dados %>% 
  select_if(is.character)
glimpse(dados12)
```

### Seleção por critérios

- Podemos definir externamente um critério para selecionar variáveis. Por exemplo, temos o nome de algumas variáveis que queremos selecionar.
- all_of() é utilizado para selecionar variáveis que atendam a um critério externo.
- any_of() é utilizado para selecionar variáveis que atendam a pelo menos um critério externo.

```{r}
dados %>% 
  select_if(is.logical) #nenhuma

dados %>% 
  select_if(is.numeric) #nenhuma

variaveis <- c("Country", "Timestamp", "Days_Indoors", "mercosul")
dados13 <- dados %>% 
  select(all_of(variaveis))
glimpse(dados13)

variaveis <- c("Country", "Timestamp", "Days_Indoors", "mercosul", "Loss_of_Smell")
dados14 <- dados %>% 
  select(any_of(variaveis))
glimpse(dados14)
```

## Filtrando observações

Para filtrar observações, podemos utilizar a função filter()

- ==: Igual a
- !=: Diferente de
- <: Menor que
- >: Maior que
- <=: Menor ou igual a
- >=: Maior ou igual a

Vamos filtrar as observações pertencentes ao mercosul.

Para aprendermos filtros, vamos usar o banco de dados *car_crash*.

```{r}
library(data.table)
car_crash <- fread("C:/Users/anton/OneDrive/Área de Trabalho/CE302---2025.2/Parte 4/Brazil Total highway crashes 2010 - 2023.csv")

library(magrittr)
library(tidyverse)

glimpse(car_crash)

```

### Filtro Simples

Vamos filtrar as observações cujo tipo de ocorrência é *sem vítima*

```{r}
# Filtrando linhas com filter()
car_crash2 <- car_crash %>% 
  filter(tipo_de_ocorrencia == "sem vítima")
glimpse(car_crash2)
```

### Filtros Combinados

- Podemos combinar filtros utilizando os operadores lógicos & (E) e | (OU).
- Vamos filtrar as observações cujo tipo de ocorrência é sem vítima envolvendo pelo menos 3 automóveis.

```{r}
## Filtros com múltiplas condições
car_crash3 <- car_crash %>% 
  filter(tipo_de_ocorrencia == "sem vítima" & automovel >= 3)
glimpse(car_crash3)
```


### Filtrando valores em um intervalo

- Podemos filtrar **valores** em um intervalo numérico utilizando a função *between*.
- Vamos filtrar as observações cujo número de automóveis envolvidos está entre 3 e 5

```{r}
car_crash4 <- car_crash %>% 
  filter(between(automovel, 3, 5))
```

- Podemos filtrar strings utilizando o operator *%in%*.
- Vamos filtrar as observações cujo tipo de ocorrência é *sem vítima* ou com *vítima*.

```{r}
tipos <- c("sem vítima", "com vítima")
tipos
car_crash5 <- car_crash %>% 
  filter(tipo_de_ocorrencia %in% tipos)
car_crash5
```

- Para filtrarmos o contrário, podemos utilizar o operador *!*, ou definirmos um operador not in como *%ni% <- Negate(%in%)*.

```{r}
car_crash6 <- car_crash %>% 
  filter(!tipo_de_ocorrencia %in% c("sem vítima", "com vítima"))
glimpse(car_crash6)

## Usando o operador %ni%
`%ni%` <- Negate(`%in%`)
car_crash7 <- car_crash %>%
  filter(tipo_de_ocorrencia %ni% c("sem vítima", "com vítima"))
glimpse(car_crash7)
```

### Buscando padrões com filter()

- Podemos buscar padrões em strings utilizando o operador *%like%*.
- Vamos filtrar as observações cujo tipo de ocorrência contém a palavra *vítima*.

```{r}
## Operador like %like%
car_crash8 <- car_crash %>% 
  filter(tipo_de_ocorrencia %like% "vítima")

glimpse(car_crash8)
```

- Podemos filtrar por textos específicos, por exemplo, *ilesa* ou *fatal*. Para isso utilizamos o *grepl*.

```{r}
car_crash9 =  car_crash %>% 
  filter(grepl("ilesa|fatal", tipo_de_ocorrencia))

glimpse(car_crash9)
```

## Ordenando e Fatiando Observações

### Ordenando Observações com arrange()

- Para ordenar observações, podemos utilizar a função *arrange()*.
- Vamos ordenar as observações do banco de dados *car_crash* pela variável *automovel* em ordem decrescente.

```{r}
## Ordenando linhas com arrange()
car_crash10 = car_crash %>% 
  arrange(desc(automovel))
glimpse(car_crash10)
```

- Podemos ordenar por mais de uma variável. Vamos ordenar as observações do banco de dados *car_crash* pela variável *automovel* em ordem decrescente e pelo número de *mortos* em ordem crescente.

```{r}
car_crash11 = car_crash %>% 
  arrange(desc(automovel), mortos) %>%
  select(automovel, mortos) %>% 
  na.exclude()
head(car_crash11)
```

### Fatiando Linhas com slice()

- Para fatiar linhas, podemos utilizar a função slice() .

```{r}
car_crash_slice1 = car_crash %>% 
  select(1:5) %>%
  slice(3:5)
car_crash_slice1
```

```{r}
car_crash_slice2 = car_crash %>% 
  select(1:5) %>%
  slice_head(n = 3)
car_crash_slice2
```

```{r}
car_crash_slice3 = car_crash %>% 
  select(1:5) %>%
  slice_tail(n = 3)
car_crash_slice3
```

## Exercícios

1 - Utilizando o banco de dados *storms* , faça o que se pede:


```{r}
View(storms)
```

- Filtre as observações cujo tipo de evento é *Tropical Depression*. Quantas observações existem?

```{r}
storms %>%
  filter(status == "tropical depression") %>%
  nrow()
```

- Filtre as observações cujo tipo de evento é Tropical Depression e a velocidade do vento é maior ou igual a 40. Quantas observações existem?

```{r}
help("storms")
storms %>%
  filter(status == "tropical depression" & wind >= 40) %>%
  nrow()
```

- Selecione as variáveis numéricas e ordene as observações pela variável pressure em ordem crescente.

```{r}
storms %>%
  select_if(is.numeric) %>%
  arrange(pressure)
```

## Renomeando, Realocando e Transmutando Colunas

### Renomeando Colunas com rename()

- Para renomear variáveis, podemos utilizar a função *rename()*.
- Vamos renomear a variável automovel para numero_automoveis no banco de dados *car_crash*.

```{r}
# Rename
car_carsh12 = car_crash %>% 
  rename(numero_automoveis = automovel)
glimpse(car_carsh12)
```

### Realocando Colunas com relocate

- Para realocar variáveis, podemos utilizar a função *relocate()*.
- Vamos realocar a variável automovel para a primeira posição no banco de dados car_crash .

```{r}
# Relocate
car_crash_relocate = car_crash %>% 
  relocate(automovel, .before = 1)
glimpse(car_crash_relocate)
```

- Vamos realocar a variável mortos para a última posição no banco de dados car_crash .

```{r}
car_crash_relocate2 = car_crash %>% 
  relocate(mortos, .after = last_col())
glimpse(car_crash_relocate2)
```

### Transformando Dados com transmute()

- Para transformar dados, podemos utilizar a função *transmute()*.
- Vamos criar uma nova variável chamada *automovel_10* que é o número de automóveis envolvidos em acidentes dividido por 10 no banco de dados *car_crash*.
- Quando utilizamos o transmute() , apenas as variáveis criadas são mantidas no novo data frame.

```{r}
# Transmute
car_crash_transmute <- car_crash %>% 
  transmute(automovel_10 = automovel / 10)
glimpse(car_crash_transmute)
```

### Alterando NA s com replace_na()

- Para alterar valores *NA* , podemos utilizar a função *replace_na()*.
- Vamos substituir os valores *NA* da variável mortos por 0 no banco de dados *car_crash*.

```{r}
# NA Replace
car_crash_replace_na <- car_crash %>%
  mutate(mortos = replace_na(mortos, 0))
glimpse(car_crash_replace_na)
```

### Classificando Dados com cut()

- Para classificar dados, podemos utilizar a *função cut()*.
- Vamos classificar a variável *automovel* em 3 categorias: *sem automóveis*, *entre 1 e 3 automóveis*, *mais do que três* no banco de dados *car_crash*.

```{r}
# Cut
car_crash_cut <- car_crash %>%
  mutate(automovel = replace_na(automovel, 0)) %>%
  mutate(automovel_cat = cut(automovel,
                             breaks = c(-Inf, 0, 3, Inf),
                             labels = c("sem automóveis",
                                        "entre 1 e 3 automóveis",
                                        "mais do que três")))
glimpse(car_crash_cut)
table( car_crash_cut$automovel, 
       car_crash_cut$automovel_cat)
```

## Sumarizando e Agrupando Dados

### Sumarizando Dados com summarise()

- Para sumarizar dados, podemos utilizar a função *summarise()*.
- Vamos sumarizar o número total de automóveis envolvidos em acidentes no banco de dados *car_crash*.

```{r}
## Summarise
car_crash13 = car_crash %>% 
  summarise(total_automoveis = sum(automovel, na.rm = TRUE))
car_crash13
sum(car_crash$automovel, na.rm = T)
```

### Sumarizando Múltiplas Variáveis com summarise()

- Podemos sumarizar mais de uma variável. Vamos sumarizar o número total de automóveis envolvidos em acidentes e o número total de mortos.

```{r}
car_crash14 = car_crash %>% 
  summarise(total_automoveis = sum(automovel, na.rm = TRUE),
            total_mortos = sum(mortos, na.rm = TRUE), 
            n = n(), 
            media_mortos = mean(mortos, na.rm = TRUE))
car_crash14
sum(car_crash$mortos, na.rm = T)
nrow(car_crash)
mean(car_crash$mortos, na.rm = T)
```

### Agrupando Dados com group_by()

- Para agrupar dados, podemos utilizar a função *group_by()*.
- Vamos agrupar o banco de dados *car_crash* pela variável *ano*.
- Primeiro, vamos criar a variável *ano* a partir da variável *data*.
- Para trabalharmos com datas, precisamos utilizar o pacote **lubridate**.
- A função *dmy()* é utilizada para transformar strings no formato dia-mês-ano em objetos do tipo *date*.
- A função *year()* é utilizada para extrair o ano de um objeto do tipo *date*.

```{r}
require(lubridate)
## Agrupamento com group_by()
car_crash15 = car_crash %>% 
  mutate(ano = year(dmy(data))) %>%
  group_by(ano)
glimpse(car_crash15)
```

### Sumarizando Dados com summarise()

- Agora vamos sumarizar o número total de automóveis envolvidos em acidentes e o número total de mortos por ano.

```{r}
car_crash16 = car_crash %>% 
  mutate(ano = year(dmy(data))) %>%
  group_by(ano) %>%
  summarise(total_automoveis = sum(automovel, na.rm = TRUE),
            total_mortos = sum(mortos, na.rm = TRUE))
head(car_crash16)
```

### Encadeando Funções

- Podemos encadear funções utilizando o operador %>%.
- Vamos filtrar as observações cujo tipo de ocorrência é com vítima e sumarizar o número total de automóveis envolvidos em acidentes e o número total de mortos.

```{r}
car_crash17 = car_crash %>% 
  filter(tipo_de_ocorrencia == "com vítima") %>%
  summarise(total_automoveis = sum(automovel, na.rm = TRUE),
            total_mortos = sum(mortos, na.rm = TRUE))
car_crash17
```

## Exercícios

Utilizando o banco de dados starwars faça o que se pede:

```{r}
View(starwars)

```


- Qual é o número total de espécies únicas presentes? Qual a frequência de indivíduos por espécie?
```{r}
starwars %>%
  summarise(n_especies = n_distinct(species))

starwars %>%
  group_by(species) %>%
  summarise(freq_especies = n()) %>%
  arrange(desc(freq_especies))
```

- Calcule a altura média de personagens masculinos e femininos.

```{r}
starwars %>% 
  filter(sex %in% c("female", "male")) %>% 
  group_by(sex) %>%
  summarise(media_altura = mean(height, na.rm = TRUE))
```

- Qual é o peso médio dos personagens de cada espécie para personagens masculinos?

```{r}
starwars %>% 
  filter(sex == "male") %>%
  group_by(species) %>%
  summarise(media_peso = mean(mass, na.rm = TRUE))
```

- Para cada espécie presente na base de dados, identifique o personagem mais pesado e seu peso correspondente.

```{r}
starwars %>% 
  group_by(species) %>%
  filter(mass == max(mass, na.rm = TRUE)) %>%
  select(species, name, mass)
```

## Trabalhando com Datas - lubridate

### Manipulação de datas 

- Quando importamos datas em R (dentro de um data frame), elas são importadas como strings.
- Precisamos, portanto, transformar essas strings em objetos do tipo date para podermos manipulá-las, como por exemplo, extrair o ano, o mês, o dia, etc.
- Podemos extrair o ano, o mês e o dia de uma data utilizando as funções year() , month() e day() .

```{r}
## Trabalhando com datas - lubridate
car_crash %>% 
  mutate(data = dmy(data)) %>%
  select(data) %>%
  glimpse()
```

```{r}
car_crash %>% 
  mutate(data = dmy(data)) %>%
  mutate(ano = year(data),
         mes = month(data),
         dia = day(data)) %>%
  select(data, ano, mes, dia) %>%
  glimpse()
```

- Podemos calcular a diferença entre duas datas utilizando a função difftime() .

```{r}
car_crash %>% 
  mutate(data = dmy(data)) %>%
  mutate(dias_desde_acidente = difftime(Sys.Date(), data, units = "days")) %>%
  select(data, dias_desde_acidente) %>%
  head()
```

- Podemos somar ou subtrair dias de uma data utilizando a função lubridate::days() .

```{r}
car_crash %>% 
  mutate(data = dmy(data)) %>%
  mutate(data_mais_10_dias = data + lubridate::days(10)) %>%
  select(data, data_mais_10_dias) %>%
  head()
```

### Manipulação de datas - Hora, minutos e segundos

- Podemos extrair a hora, os minutos e os segundos de uma data utilizando as funções hour() , minute() e second() .

```{r}
## Extraindo componentes de data e hora
data <- ymd_hms("2023-08-21 15:30:45")
ano <- year(data)
mes <- month(data)
dia <- day(data)
hora <- hour(data)
minuto <- minute(data)
segundo <- second(data)

print(ano)
print(mes)
print(dia)
print(hora)
print(minuto)
print(segundo)
```

### Conversão de fuso horário

- Podemos converter o fuso horário de uma data utilizando a função with_tz() .

```{r}
# Data original no fuso horário de Nova Iorque
data_ny <- ymd_hms("2025-10-21 12:00:00", tz = "America/New_York")

# Converter para o fuso horário de Londres
data_london <- with_tz(data_ny, tz = "Europe/London")

print(data_ny)
print(data_london)
```

## Exercícios - Datas

Utilizando o banco de dados car_crash faça o que se pede:

- Quais os meses do ano com maior número de acidentes fatais?

```{r}
## Exercícios com datas
car_crash %>% 
  mutate(data = dmy(data)) %>%
  mutate(ano = year(data),
         mes = month(data)) %>%
  select(data, ano, mes, mortos) %>%
  filter(mortos > 0) %>% 
  group_by(mes) %>%
  summarise(total_mortos = sum(mortos)) %>% 
  arrange(desc(total_mortos))
```

- Quais os dias da semana com maior número de acidentes fatais?
  Dica: Busque por uma função que retorne o dia da semana a partir de uma data.

```{r}
car_crash %>% 
  mutate(data = dmy(data)) %>%
  mutate(dia_semana = lubridate::wday(data, label = T, abbr = F)) %>%
  select(dia_semana, mortos) %>%
  filter(mortos > 0) %>% 
  group_by(dia_semana) %>%
  summarise(total_mortos_dia = sum(mortos)) %>% 
  arrange(desc(total_mortos_dia))
```

## Pivotagem de Dados

### O que é tidy data?

Hadley Wickham, em seu artigo “Tidy Data” (2014), define que um conjunto de dados é tidy se:

1. Cada variável forma uma coluna.
2. Cada observação forma uma linha.
3. Cada tipo de unidade observacional forma uma tabela.

Existem dois formatos de dados que podem ser tidy:

- Dados em formato wide.
- Dados em formato long.

### Dados no formato wide

- Cada variável é representada por uma coluna separada e cada observação (ou instância) ocupa uma única linha.
- Adequado para conjuntos de dados com poucas variáveis, onde as informações são bem condensadas.

### Dados no formato long

Exemplos

#### Considere o seguinte conjunto de dados em formato wide:

|-----------------------------------|
| id | nome | idade | sexo | altura |
| :--- | :--- | :--- | :--- | :--- |
| 1 | Ana | 25 | F | 1.65 |
| 2 | João | 30 | M | 1.80 |
| 3 | Maria | 22 | F | 1.70 |
| 4 | Pedro | 28 | M | 1.75 |
|---------------------------|

#### Para passar para o formato long, basta empilhar as variáveis:

|-----------------|
| id | variável | valor |
| :--- | :--- | :--- | 
| 1  | nome | Ana |
| 1  | idade | 25 |
| 1 | sexo | F |
| 1 | altura | 1.65 |
| 2 | nome | João |
| 2 | idade | 30 |
| 2 | sexo | M |
| 2 | altura | 1.80 |
|-----------------|

#### Considere o seguinte conjunto de dados com informações sobre tratamento de indivíduos com pedra nos rins:

| Tamanho da pedra | Tratamento A (Recuperados) | Tratamento A (Falhas) | Tratamento B (Recuperados) | Tratamento B (Falhas) |
| :--- | :--- | :--- | :--- | :--- |
| Pequena | 10 | 5 | 15 | 3 |
| Média | 5 | 3 | 10 | 2 |
| Grande | 2 | 1 | 5 | 1 |

#### Para passar para o formato **long**, basta empilhar as variáveis:

| Tamanho da pedra | Tratamento | Recuperados | Falhas |
| :--- | :--- | :--- | :--- |
| Pequena | A | 10 | 5 |
| Pequena | B | 15 | 3 |
| Média | A | 5 | 3 |
| Média | B | 10 | 2 |
| Grande | A | 2 | 1 |
| Grande | B | 5 | 1 |

### Pivotando dados em R

- Vamos utilizar o banco de dados table1 .
- Dados de casos reportados de Tuberculose e o tamanho da população em dois anos para três países.
- Esses dados são provenientes dos dados WHO.

```{r}
table1
```

- A função pivot_wider() é utilizada para transformar dados de formato long para wide.

- A função pivot_wider() requer os seguintes argumentos:
  - names_from : coluna que contém os nomes das variáveis que serão transformadas em colunas.
  - values_from : coluna que contém os valores das variáveis que serão transformadas em colunas.

- Vamos transformar os dados de table1 para o formato wide. Suponha que queremos que os dados sejam organizados por país e ano, e as observações sejam os casos de tuberculose.

```{r}
table1 %>%
  select(-population) %>%
  pivot_wider(names_from = year,
              values_from = cases)

```

### Pivotando com mais de uma variável

- Suponha que queremos que os dados sejam organizados por país, e as observações sejam os casos de tuberculose, separados por ano e tamanho da população.

```{r}
table1 %>%
  pivot_wider(names_from = year,
              values_from = c(cases, population))

```

- A função pivot_longer() é utilizada para transformar dados de formato wide para long.
- A função pivot_longer() requer os seguintes argumentos:
  - cols : colunas que serão empilhadas.
  - names_to : coluna que conterá os nomes das variáveis empilhadas.
  - values_to : coluna que conterá os valores das variáveis empilhadas.
  - values_fill : valor que preencherá as células vazias.
  - values_fn : função que será aplicada aos valores empilhados.

- Vamos transformar os dados de table1 para o formato long. Suponha que queremos que os dados sejam organizados por país, e as observações sejam os casos de tuberculose e a população.

```{r}
table1 %>%
  pivot_longer(cols = c(cases, population),
               names_to = "variable",
               values_to = "total")

```

### Separando observações

- Algumas vezes, as observações estão agrupadas em uma única coluna e precisamos separar elas.
- A função separate() é utilizada para separar observações em diferentes colunas.
- Observe os dados em table3.

```{r}
table3
```

- Suponha que queremos separar a coluna rate em duas colunas: cases e population .

```{r}
table3 %>%
  separate(rate, into = c("cases",
                          "population"))

```

### Juntando observações

-  função unite() é utilizada para juntar observações de diferentes colunas em uma única coluna.
- Suponha que queremos juntar as colunas cases e population em uma única coluna chamada rate .

```{r}
table1 %>%
  unite(rate, cases, population, sep = "/")
```

### Exercícios

Utilizando os dados de flights , do pacote *nycflights13* , crie uma matriz que mostra o número de voos entre cada par de aeroportos.

```{r}
# Utilizando os dados do pacote nycflights13
require(nycflights13)
library(nycflights13)
flights %>% 
  count(origin, dest) %>% 
  pivot_wider(names_from = origin, 
              values_from = n, 
              values_fill = 0)
```

## Strings

### Manipulando Strings em R

- Strings são sequências de caracteres que representam texto.
- Em R, strings são representadas por aspas simples (’ ’) ou aspas duplas (” “).
- O pacote stringr , parte do tidyverse, oferece diversas funções para manipulação de strings.

### Funções Básicas do stringr

- str_length(): Retorna o comprimento de uma string.
- str_to_lower(): Converte uma string para minúsculas.
- str_to_upper(): Converte uma string para maiúsculas.
- str_sub(): Extrai uma substring de uma string.
- str_replace(): Substitui uma parte de uma string por outra.
- str_detect(): Verifica se uma string contém um padrão específico.

### Exemplos de Manipulação de Strings

```{r}
library(stringr)
texto <- "Olá, Mundo!"

# Comprimento da string
str_length(texto)

# Converter para minúsculas
str_to_lower(texto)

# Converter para maiúsculas
str_to_upper(texto)

str_to_title(texto)

str_to_sentence(texto)

# Extrair substring
str_sub(texto, 1, 3)

# Substituir parte da string
str_replace(texto, "Mundo", "R")

# Verificar se a string contém um padrão
str_detect(texto, "Mundo")
str_detect(texto, "R!")
```

### Regex Básico

- Regex (expressões regulares) são padrões utilizados para buscar e manipular strings.
- Alguns metacaracteres comuns:
- . : Corresponde a qualquer caractere.
- ^ : Início da string.
- $ : Fim da string.
- * : Zero ou mais ocorrências do caractere anterior.
- + : Uma ou mais ocorrências do caractere anterior.
- ? : Zero ou uma ocorrência do caractere anterior.
- [] : Conjunto de caracteres.
- | : Operador “ou”.

#### Exemplos de Regex

```{r}
# Expressões Regulares (Regex)

# Corresponder qualquer caractere
str_detect("abc", "a.c") # TRUE

# Início da string
str_detect("abc", "^a")   # TRUE

# Fim da string
str_detect("abc", "c$")   # TRUE

# Zero ou mais ocorrências
str_detect("aaab", "a*b") # TRUE

# Uma ou mais ocorrências
str_detect("aaab", "a+b") # TRUE

# Conjunto de caracteres: corresponde a 'a', 'b' ou 'c'
str_detect("abc", "[abc]") # TRUE

# Operador "ou": corresponde a 'cat' ou 'dog'
str_detect("I have a cat", "cat|dog") # TRUE
```

## Para saber mais

[Cheatsheet de expressões regulares](https://github.com/rstudio/cheatsheets/blob/main/regex.pdf)
[Cheatsheet do pacote stringr](https://github.com/rstudio/cheatsheets/blob/main/strings.pdf)
[Testar o Regex online](https://regexr.com/)
[Palavra cruzada](https://regexcrossword.com/)

## Combinação de dados

### Concatenação

- A concatenação permite adicionar novas observações a uma tabela ou novas variáveis.
- Seja por linha ou colunas, entradas com NA são criadas para os índices que não foram especicados.

### Criação de um tibble

#### Criação por colunas 

```{r}
library(tidyverse)
# Tabela com alunos do curso de
# Matemática e de Estatística.
df1 <- tibble(
mat = c(256, 487, 965,
125, 458, 874, 963),
nome = c("João", "Vanessa", "Tiago",
"Luana", "Gisele", "Pedro",
"André"),
curso = c("Mat", "Mat", "Est", "Est",
"Est", "Mat", "Est"),
prova1 = c(80, 75, 95, 70, 45, 55, 30),
prova2 = c(90, 75, 80, 85, 50, 75, NA),
prova3 = c(80, 75, 75, 50, NA, 90, 30),
faltas = c(4, 4, 0, 8, 16, 0, 20))

df1

```


#### Criação por linhas

```{r}
# Informações de cadastro dos alunos
# em outra base de dados.
df_extra <- tribble(
~mat, ~nome, ~idade, ~bolsista,
256, 'João' , 18, "S",
965, 'Tiago' , 18, "N",
285, 'Tiago' , 22, "N",
125, 'Luana' , 21, "S",
874, 'Pedro' , 19, "N",
321, 'Mia' , 18, "N",
669, 'Luana' , 19, "S",
967, 'André' , 20, "N",
)

df_extra
```

### Concatenação

#### De linhas (vertical)

```{r}
# Concatenação na vertical (pilha).
bind_rows(df1[1:3, c(1, 3, 5)],
df1[5:7, c(1, 3, 5, 4)],
df1[4, c(1, 5, 4)])
```

#### De colunas (horizontal)

```{r}
# Concatenação na horizontal (fila).
bind_cols(df1[, c(1:3)],
df1[, c(6:7)])

```

### Junções

- Junções permitem parear dados de tabelas separadas quando elas possuem uma chave (ou chave primária).
- As operações de junção podem ser inicialmente de 4 tipos:
  - Junção por interseção (inner join).
  - Junção por união (full join).
  - Junção à esquerda (left join).
  - Junção à direita (right join).
  - Existe também os exclusive joins.

```{r}
# Full join = união.
full_join(df1, df_extra,
by = c("mat" = "mat", "nome"))
```

```{r}
# Inner join = intersecção.
inner_join(df1,
df_extra,
by = c("mat" = "mat",
"nome"))
```

```{r}
# Todos os que estão na 1º tabela
left_join(df1, df_extra,
by = c("mat" = "mat",
"nome"))
# Todos os que estão na 2º tabela
right_join(df1, df_extra,
by = c("mat" = "mat",
"nome"))

```

```{r}
# Os da 2º que não aparecem na 1º.
anti_join(df1, df_extra,
by = c("mat" = "mat",
"nome"))
```

### Exportação de Dados

#### Exportando arquivos em texto pleno

```{r}
#write_csv(df1,
          #file = "Nome_do_arquivo.csv")
```

#### Arquivo binário do R

```{r}
#save(df1,
     #file = "Nome_do_arquivo.RData")
## Carregando arquivo .RData
#load("Nome_do_arquivo.RData")
```

#### Criando planilha eletronica

```{r}
#library(writexl)
#write_xlsx(df1, "Nome_do_arquivo.xlsx")
```



