---
title: "Erros comuns e exercícios"
output: html_document
date: "2025-10-12"
---

# Erros Comuns e Exercícios

## Erros comuns

### Estruturas de Controle (IF-ELSE, SWITCH)

1. Não Usar a Versão Vetorial: O erro mais clássico em R é tentar aplicar a estrutura if-else padrão (não vetorizada) a um vetor com mais de um elemento. O R testará apenas o primeiro elemento do vetor, emitirá um warning, e o resultado será inesperado para os demais elementos.

2. Lógica Incompleta no IF-ELSE IF: Em cadeias de IF-ELSE IF, esquecer que o R só avalia a próxima condição se a anterior for FALSA. Isso pode levar a erros lógicos, especialmente em intervalos numéricos, se não forem definidos corretamente (ex: usar > 10 e depois > 5 sem considerar a ordem).

3. Confundir o SWITCH do R: Em R, a função switch() avalia uma expressão e a compara com valores literais, retornando o valor da expressão correspondente. Em outras linguagens, é um bloco de controle de fluxo.

### Estruturas de Repetição (FOR, WHILE, REPEAT)

1. Loops Infinitos no WHILE/REPEAT: Esquecer de incluir uma instrução dentro do bloco do loop que modifique a variável de controle, garantindo que a condição de parada será atingida.

2. Ineficiência por Falta de Vetorização: Usar loops FOR para realizar operações que o R pode fazer de forma muito mais rápida usando funções vetorizadas (como sum(), mean(), ou a família apply). Vetorização é quase sempre mais rápida em R.

3. Não Pré-alocar Espaço (Em Loops FOR): Quando se constrói um vetor ou lista dentro de um FOR, não inicializar o objeto com o tamanho final (e.g., rend <- numeric(n_meses) no seu exemplo). O R tem que realocar o objeto na memória a cada iteração, tornando o código muito mais lento para grandes quantidades de dados.

### Funções

1. Falta de Tratamento de Exceções: Não incluir verificações de validade para os argumentos de entrada (e.g., o peso ou altura não podem ser negativos na função imc). O uso de stop() para entradas inválidas é fundamental para que sua função seja robusta.

2. Efeitos Colaterais (Side Effects): Modificar variáveis que estão fora do escopo da função (variáveis globais) de forma desnecessária. Isso torna o código difícil de rastrear e depurar.

3. Nomes Não Descritivos: Usar nomes de funções e argumentos que não comunicam claramente o propósito (e.g., f() em vez de calcular_media()).

## Exercícios

### Estruturas de Controle e Lógica Condicional (IF-ELSE e SWITCH)

#### 1. Calculadora de Descontos Simples (IF-ELSE):

- Crie uma variável valor_compra.

- Use uma estrutura IF-ELSE IF aninhada para aplicar os seguintes descontos:

  - Se valor_compra for maior ou igual a *R$ 300,00*, aplique 15% de desconto.

  - Se valor_compra estiver entre *R$ 100,00* e *R$ 299,99*, aplique 5% de desconto.

  - Caso contrário (abaixo de R$ 100,00), não aplique desconto (0%).

- Imprima o valor final a ser pago.

**Solução 1**, para apenas um valor

```{r}

valor_compra_i <- sample(10:1000, 1)

if ((valor_compra_i > 100) & (valor_compra_i < 299)) {
  valor_compra_f <- valor_compra_i * 0.95
  compra <- paste("Seu desconto foi de 5%, o valor original era: ", valor_compra_i, "seu novo valor é: ", valor_compra_f)
} else if (valor_compra_i >= 300) {
  valor_compra_f <- valor_compra_i * 0.85
  compra <- paste("Seu desconto foi de 15%, o valor original era: ", valor_compra_i, "seu novo valor é: ", valor_compra_f)
} else {
  compra <- paste("Você não teve desconto. Seu valor é: ", valor_compra_i)
}

print(compra)

```

**Solução 2**, para uma série de valores

```{r}

valor_compra <- sample(10:1000, 6)

valor_final <- ifelse (((valor_compra > 100) & (valor_compra < 299)), valor_compra * 0.95, ifelse((valor_compra >= 300), valor_compra * 0.85, valor_compra))

resultado <- data.frame(Valor_Original = valor_compra, Valor_Final = valor_final)
print(resultado)

```


#### 2. Mapeamento de Cores (SWITCH)

- Crie uma variável idioma com os valores "pt" (português), "en" (inglês) ou "es" (espanhol).

- Use a estrutura SWITCH para traduzir o nome de uma cor. Por exemplo, se a entrada for "red", o SWITCH deve retornar:

  - "pt": "vermelho"

  - "en": "red"

  - "es": "rojo"

- Defina um caso de escape que retorne "Idioma não suportado" se a entrada for diferente dos três idiomas válidos.

```{r}

cor <- "vermelho"

idioma <- switch (cor,
  "vermelho" = "Português. Em inglês é red e espanhol rojo",
  "rojo" = "Espanhol Em inglês é red e português vermelho",
  "red" = "Inglês. Em português é vermelho e espanhol rojo",
  "Idioma não suportado"
)

print(idioma)

```

#### 3. Classificação Vetorial de Notas (ifelse ou case_when):

- Crie um vetor pontuacoes com 10 notas aleatórias entre 0 e 100 (e.g., sample(0:100, 10)).

- Usando a função dplyr::case_when() (ou ifelse() aninhado se não quiser usar o dplyr), crie um novo vetor conceito com base nas seguintes regras (Aplicação Vetorial!):

  - Notas ≥90: "A"

  - Notas ≥80 e <90: "B"

  - Notas ≥70 e <80: "C"

  - Notas <70: "D"

- Imprima o vetor original de notas e o vetor de conceitos.

```{r}

notas <- sample(0:100, 10)

casos <- dplyr::case_when(notas >= 90 ~ "A",
                          notas >= 80 ~ "B",
                          notas >= 70 ~ "C",
                          TRUE ~ "D")

resultado <- data.frame(notas, casos)
print(resultado)

```

### Estruturas de Repetição (Loops)

#### 4. Simulador de Juros Compostos (FOR):

- Defina um capital_inicial (e.g., 1000), uma taxa_juros (e.g., 0.05) e o numero_meses (e.g., 6).

- Crie um vetor saldo com numero_meses posições e pré-aloque o capital_inicial na primeira posição.

- Use um loop FOR para calcular e armazenar o saldo final para cada mês (mês a mês).
  - Dica: Saldo Atual = Saldo Anterior * (1 + taxa_juros)
  
```{r}

capital_inicial <- sample(500:2000, 1)
opcoes_juros <- c(0.01, 0.02, 0.03, 0.04, 0.05) # sample só cria sequências de números inteiros
taxa_juros <- sample(opcoes_juros, 1)
numero_meses <- sample(5:24, 1)

saldo <- numeric(numero_meses)
saldo[1] <- capital_inicial


for (i in 2:numero_meses) {
  saldo[i] <- saldo[i - 1] * (1 + taxa_juros)
}

resultado <- data.frame(Mês = 1:numero_meses, Capital_Inicial = capital_inicial, Taxa = taxa_juros, Saldo = saldo)
print(resultado)

```

#### 5. Adivinhe o Número (WHILE/REPEAT com break):

- Crie uma variável numero_secreto (e.g., 42).

- Use a função sample(1:100, 1) para gerar um palpite aleatório a cada tentativa.

- Use um loop WHILE (ou REPEAT) para continuar gerando palpites até que o palpite seja igual ao numero_secreto.

- Dentro do loop, use um contador de tentativas.

- Quando o número for adivinhado, use break para sair do loop e imprima o número total de tentativas necessárias.

```{r}

numero_secreto <- sample(1:100, 1)
palpite <- sample(1:100, 1)
tentativas <- 1

while (palpite != numero_secreto) {
  tentativas <- tentativas + 1
  palpite <- sample(1:100, 1)
}

print(paste("O número secreto era: ", numero_secreto))
print(paste("O número foi descoberto em ", tentativas, "tentativas."))
```

#### 6. Soma de Ímpares (FOR com next):

- Crie um vetor numeros de 1 a 100.

- Crie uma variável soma_impares inicializada em 0.

- Use um loop FOR para iterar sobre o vetor.

- Dentro do loop, use uma estrutura IF para verificar se o número atual é par (numero %% 2 == 0).

- Se for par, use a instrução next para pular a adição.

- Se for ímpar, adicione o número à soma_impares.

- Imprima a soma_impares final.

```{r}

numeros <- 1:100
soma_impares <- 0

for (i in numeros) {
  if (i %% 2 == 0) next
  soma_impares <- soma_impares + i
}

print(soma_impares)

```


### Funções e Tratamento de Exceções 

#### 7. Função de Cálculo de Média Aritmética:

- Crie uma Função chamada calcular_media_vetor que aceite um argumento: vetor_dados.

- Tratamento de Exceção: Dentro da função, use stop() para verificar se o vetor_dados não é numérico (!is.numeric(vetor_dados)). Se não for, emita a mensagem de erro: "Erro: O argumento deve ser um vetor numérico.".

- A função deve retornar a média dos valores do vetor.

- Teste a função passando:

  - Um vetor numérico válido (e.g., c(10, 20, 30)).

  - Um vetor de caracteres (e.g., c("a", "b", "c")) para testar o stop().
